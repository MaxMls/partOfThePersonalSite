<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circles in Circle Simulation</title>
    <style>
        body { display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
        canvas { background-color: #f0f0f0; }
    </style>
</head>
<body>
    <canvas id="canvas" width="600" height="600"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        const mainCircleRadius = 250;
        const numCircles = 20;
        const circleRadius = 35;
        const friction = 0.95;  // Slows down movement over time
        const circles = [];

        // Helper functions
        function getDistance(x1, y1, x2, y2) {
            return Math.hypot(x2 - x1, y2 - y1);
        }

        function randomPosition() {
            const angle = Math.random() * 2 * Math.PI;
            const radius = Math.random() * (mainCircleRadius - circleRadius);
            return {
                x: width / 2 + radius * Math.cos(angle),
                y: height / 2 + radius * Math.sin(angle)
            };
        }

        function isIntersecting(c1, c2) {
            return getDistance(c1.x, c1.y, c2.x, c2.y) < circleRadius * 2;
        }

        // Circle constructor
        class Circle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.dx =0;
                this.dy = 0;
            }

            move() {
                this.x += this.dx;
                this.y += this.dy;

                // Apply friction to slow down over time
                this.dx *= friction;
                this.dy *= friction;

                // Keep circles inside the main circle
                const distanceToCenter = getDistance(this.x, this.y, width / 2, height / 2);
                if (distanceToCenter + circleRadius > mainCircleRadius) {
                    const angle = Math.atan2(this.y - height / 2, this.x - width / 2);
                    this.x = width / 2 + (mainCircleRadius - circleRadius) * Math.cos(angle);
                    this.y = height / 2 + (mainCircleRadius - circleRadius) * Math.sin(angle);
                    this.dx *= -1; 
                    this.dy *= -1;
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, circleRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 150, 200, 0.8)';
                ctx.fill();
                ctx.strokeStyle = '#003366';
                ctx.stroke();
                ctx.closePath();
            }
        }

        // Generate circles and place them randomly without initial intersection
        for (let i = 0; i < numCircles; i++) {
            let position;
            let overlapping;
                overlapping = false;
                position = randomPosition();
                const newCircle = new Circle(position.x, position.y);

            

            circles.push(new Circle(position.x, position.y));
        }

        function update() {
            ctx.clearRect(0, 0, width, height);

            // Draw main circle
            ctx.beginPath();
            ctx.arc(width / 2, height / 2, mainCircleRadius, 0, Math.PI * 2);
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();

            let moving = false;
            for (let i = 0; i < circles.length; i++) {
                const circle = circles[i];
                circle.move();

                // Check for collision with other circles
                for (let j = i + 1; j < circles.length; j++) {
                    const other = circles[j];
                    if (isIntersecting(circle, other)) {
                        // Move circles apart
                        const angle = Math.atan2(other.y - circle.y, other.x - circle.x);
                        const overlap = circleRadius * 2 - getDistance(circle.x, circle.y, other.x, other.y);
                        circle.dx -= overlap * Math.cos(angle) * 0.05;
                        circle.dy -= overlap * Math.sin(angle) * 0.05;
                        other.dx += overlap * Math.cos(angle) * 0.05;
                        other.dy += overlap * Math.sin(angle) * 0.05;
                    }
                }

                // Check if still moving
                if (Math.abs(circle.dx) > 0.01 || Math.abs(circle.dy) > 0.01) {
                    moving = true;
                }

                circle.draw();
            }

            // Continue animation while circles are moving
            if (moving) {
                requestAnimationFrame(update);
            }
        }

        // Start the animation
        update();
    </script>
</body>
</html>
